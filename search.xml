<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang设计模式-单例模式</title>
    <url>/2020/04/15/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式用于系统运行时只需一个实例的时候，可节省系统开支</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>本例中实现一个饿汉式单例模式<br><img src="/images/singleton.gif" alt=""></p>
<a id="more"></a>

<h3 id="以实现一个负载均衡器为例"><a href="#以实现一个负载均衡器为例" class="headerlink" title="以实现一个负载均衡器为例"></a>以实现一个负载均衡器为例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type LoadBalancer interface &#123;</span><br><span class="line">	AddServer(string)</span><br><span class="line">	GetServer() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var lb LoadBalancer</span><br><span class="line"></span><br><span class="line">type SimpleLoadBalancer struct &#123;</span><br><span class="line">	serverMap map[string]struct&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSimpleLoadBalancer() *SimpleLoadBalancer &#123;</span><br><span class="line">	m :&#x3D; make(map[string]struct&#123;&#125;)</span><br><span class="line">	return &amp;SimpleLoadBalancer&#123;serverMap: m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SimpleLoadBalancer) AddServer(srv string) &#123;</span><br><span class="line">	s.serverMap[srv] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SimpleLoadBalancer) GetServer() string &#123;</span><br><span class="line">	for srv :&#x3D; range s.serverMap &#123;</span><br><span class="line">		return srv</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetLoadBalancer() LoadBalancer &#123;</span><br><span class="line">	return lb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	lb &#x3D; NewSimpleLoadBalancer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	lb :&#x3D; GetLoadBalancer()</span><br><span class="line">	lb.AddServer(&quot;server 1&quot;)</span><br><span class="line">	lb.AddServer(&quot;server 2&quot;)</span><br><span class="line">	lb.AddServer(&quot;server 3&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(lb.GetServer())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/singleton_client.PNG" alt=""></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本次实现中未考虑并发，实际运用时，需要考虑serverMap的并发访问</p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-原型模式</title>
    <url>/2020/04/16/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>原型模式用于需要模板的时候，比如本例中的周报</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/prototype.gif" alt=""></p>
<a id="more"></a>

<h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;encoding&#x2F;json&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Attachment struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAttachment(name string) *Attachment &#123;</span><br><span class="line">	return &amp;Attachment&#123;Name: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Attachment) GetName() string &#123;</span><br><span class="line">	return a.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Attachment) SetName(name string) &#123;</span><br><span class="line">	a.Name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Attachment) Download() &#123;</span><br><span class="line">	fmt.Println(&quot;downloading...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type WeekLog struct &#123;</span><br><span class="line">	Name    string</span><br><span class="line">	Date    string</span><br><span class="line">	Content string</span><br><span class="line">	Attach  *Attachment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewWeekLog(name string, date string, content string, attach *Attachment) *WeekLog &#123;</span><br><span class="line">	return &amp;WeekLog&#123;Name: name, Date: date, Content: content, Attach: attach&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) GetName() string &#123;</span><br><span class="line">	return w.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) SetName(name string) &#123;</span><br><span class="line">	w.Name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) GetDate() string &#123;</span><br><span class="line">	return w.Date</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) SetDate(d string) &#123;</span><br><span class="line">	w.Date &#x3D; d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) GetContent() string &#123;</span><br><span class="line">	return w.Date</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) SetContent(c string) &#123;</span><br><span class="line">	w.Content &#x3D; c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) GetAttach() *Attachment &#123;</span><br><span class="line">	return w.Attach</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WeekLog) SetAttach(a *Attachment) &#123;</span><br><span class="line">	w.Attach &#x3D; a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; deep clone</span><br><span class="line">func (w *WeekLog) Clone() *WeekLog &#123;</span><br><span class="line">	data, err :&#x3D; json.Marshal(w)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	var c WeekLog</span><br><span class="line">	json.Unmarshal(data, &amp;c)</span><br><span class="line">	return &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	log :&#x3D; NewWeekLog(&quot;my weeklog&quot;, &quot;2020-4-16&quot;, &quot;log log log&quot;, NewAttachment(&quot;my attachment&quot;))</span><br><span class="line">	fmt.Printf(&quot;[prototype]: %+v\n&quot;, log)</span><br><span class="line">	clone :&#x3D; log.Clone()</span><br><span class="line">	fmt.Printf(&quot;[clone]: %+v&quot;, clone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/prototype_client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-工厂方法模式</title>
    <url>/2020/04/13/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂方法模式可以解决简单工厂模式中频繁修改工厂类的问题</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/factory_method.jpg" alt=""></p>
<a id="more"></a>

<h3 id="创建Logger接口"><a href="#创建Logger接口" class="headerlink" title="创建Logger接口"></a>创建Logger接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Logger interface &#123;</span><br><span class="line">	WriteLog()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现FileLogger和DatabaseLogger"><a href="#实现FileLogger和DatabaseLogger" class="headerlink" title="实现FileLogger和DatabaseLogger"></a>实现FileLogger和DatabaseLogger</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type FileLogger struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewFileLogger() *FileLogger &#123;</span><br><span class="line">	return &amp;FileLogger&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *FileLogger) WriteLog() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m write log to file...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type DatabaseLogger struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewDatabaseLogger() *DatabaseLogger &#123;</span><br><span class="line">	return &amp;DatabaseLogger&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *DatabaseLogger) WriteLog() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m write log to database...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义LoggerFactory接口"><a href="#定义LoggerFactory接口" class="headerlink" title="定义LoggerFactory接口"></a>定义LoggerFactory接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type LoggerFactory interface &#123;</span><br><span class="line">	CreateLogger() Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现FileLoggerFactory和DatabaseLoggerFactory"><a href="#实现FileLoggerFactory和DatabaseLoggerFactory" class="headerlink" title="实现FileLoggerFactory和DatabaseLoggerFactory"></a>实现FileLoggerFactory和DatabaseLoggerFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type FileLoggerFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewFileLoggerFactory() *FileLoggerFactory &#123;</span><br><span class="line">	return &amp;FileLoggerFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *FileLoggerFactory) CreateLogger() Logger &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m open file...&quot;)</span><br><span class="line">	return NewFileLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type DatabaseLoggerFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewDatabaseLoggerFactory() *DatabaseLoggerFactory &#123;</span><br><span class="line">	return &amp;DatabaseLoggerFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *DatabaseLoggerFactory) CreateLogger() Logger &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m open database...&quot;)</span><br><span class="line">	return NewDatabaseLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f :&#x3D; NewDatabaseLoggerFactory()</span><br><span class="line">	logger :&#x3D; f.CreateLogger()</span><br><span class="line">	logger.WriteLog()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/factory_method_client.PNG" alt=""></p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>是否在golang中有更加轻便的实现？</p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-建造者模式</title>
    <url>/2020/04/17/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>该模式作用于产品的生产过程</p>
<h3 id="本例以生产一个游戏角色为例，-类图"><a href="#本例以生产一个游戏角色为例，-类图" class="headerlink" title="本例以生产一个游戏角色为例， 类图"></a>本例以生产一个游戏角色为例， 类图</h3><p><img src="/images/builder.gif" alt=""></p>
<a id="more"></a>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Actor struct &#123;</span><br><span class="line">	Type string</span><br><span class="line">	Sex string</span><br><span class="line">	Face string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) SetType(t string) &#123;</span><br><span class="line">	a.Type &#x3D; t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) GetType() string &#123;</span><br><span class="line">	return a.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) SetSex(s string) &#123;</span><br><span class="line">	a.Sex &#x3D; s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) GetSex() string &#123;</span><br><span class="line">	return a.Sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) SetFace(f string) &#123;</span><br><span class="line">	a.Face &#x3D; f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Actor) GetFace() string &#123;</span><br><span class="line">	return a.Face</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type ActorBuilder interface &#123;</span><br><span class="line">	BuildType()</span><br><span class="line">	BuildSex()</span><br><span class="line">	BuildFace()</span><br><span class="line">	CreateActor() *Actor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type HeroBuilder struct &#123;</span><br><span class="line">	actor *Actor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewHeroBuilder() *HeroBuilder &#123;</span><br><span class="line">	return &amp;HeroBuilder&#123;actor: new(Actor)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HeroBuilder) CreateActor() *Actor &#123;</span><br><span class="line">	return h.actor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HeroBuilder) BuildType() &#123;</span><br><span class="line">	h.actor.SetType(&quot;Hero&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HeroBuilder) BuildSex() &#123;</span><br><span class="line">	h.actor.SetSex(&quot;Male&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HeroBuilder) BuildFace() &#123;</span><br><span class="line">	h.actor.SetFace(&quot;Cool&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AngleBuilder struct &#123;</span><br><span class="line">	actor *Actor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAngleBuilder() *AngleBuilder &#123;</span><br><span class="line">	return &amp;AngleBuilder&#123;actor: new(Actor)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AngleBuilder) BuildType() &#123;</span><br><span class="line">	a.actor.SetType(&quot;Angle&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AngleBuilder) BuildSex() &#123;</span><br><span class="line">	a.actor.SetSex(&quot;Female&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AngleBuilder) BuildFace() &#123;</span><br><span class="line">	a.actor.SetFace(&quot;mystical&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AngleBuilder) CreateActor() *Actor &#123;</span><br><span class="line">	return a.actor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type ActorController struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *ActorController) construct(b ActorBuilder) *Actor &#123;</span><br><span class="line">	b.BuildType()</span><br><span class="line">	b.BuildSex()</span><br><span class="line">	b.BuildFace()</span><br><span class="line">	return b.CreateActor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><figcaption><span>main</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	b :&#x3D; NewAngleBuilder()</span><br><span class="line">	c :&#x3D; new(ActorController)</span><br><span class="line">	actor :&#x3D; c.construct(b)</span><br><span class="line">	fmt.Printf(&quot;my face is %v&quot;, actor.Face)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/builder_client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-抽象工厂模式</title>
    <url>/2020/04/14/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>抽象工厂模式可以用于生成一系列相关联的产品，解决工厂方法模式中工厂过多问题</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/abstract_factory.jpg" alt=""></p>
<a id="more"></a>

<h3 id="定义产品：Button、TextField、ComboBox"><a href="#定义产品：Button、TextField、ComboBox" class="headerlink" title="定义产品：Button、TextField、ComboBox"></a>定义产品：Button、TextField、ComboBox</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Button interface &#123;</span><br><span class="line">	Display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SpringButton struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringButton) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SpringButton...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SummerButton struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerButton) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SummerButton...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type TextField interface &#123;</span><br><span class="line">	Display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SpringTextField struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringTextField) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SpringTextField...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SummerTextField struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerTextField) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SummerTextField...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type ComboBox interface &#123;</span><br><span class="line">	Display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SpringComboBox struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringComboBox) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SpringComboBox...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SummerComboBox struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerComboBox) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;i&#39;m SummerComboBox...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义抽象工厂"><a href="#定义抽象工厂" class="headerlink" title="定义抽象工厂"></a>定义抽象工厂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type SkinFactory interface &#123;</span><br><span class="line">	CreateButton() Button</span><br><span class="line">	CreateTextField() TextField</span><br><span class="line">	CreateComboBox() ComboBox</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SpringSkinFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringSkinFactory) CreateButton() Button &#123;</span><br><span class="line">	fmt.Println(&quot;create spring style...&quot;)</span><br><span class="line">	return new(SpringButton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringSkinFactory) CreateTextField() TextField &#123;</span><br><span class="line">	fmt.Println(&quot;create spring style...&quot;)</span><br><span class="line">	return new(SpringTextField)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SpringSkinFactory) CreateComboBox() ComboBox &#123;</span><br><span class="line">	fmt.Println(&quot;create spring style...&quot;)</span><br><span class="line">	return new(SpringComboBox)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SummerSkinFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerSkinFactory) CreateButton() Button &#123;</span><br><span class="line">	fmt.Println(&quot;create summer style...&quot;)</span><br><span class="line">	return new(SummerButton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerSkinFactory) CreateTextField() TextField &#123;</span><br><span class="line">	fmt.Println(&quot;create summer style...&quot;)</span><br><span class="line">	return new(SummerTextField)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *SummerSkinFactory) CreateComboBox() ComboBox &#123;</span><br><span class="line">	fmt.Println(&quot;create summer style...&quot;)</span><br><span class="line">	return new(SummerComboBox)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f :&#x3D; new(SummerSkinFactory)</span><br><span class="line">	b :&#x3D; f.CreateButton()</span><br><span class="line">	b.Display()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/abstract_factory_client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-桥接模式</title>
    <url>/2020/04/23/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>桥接模式适用于类的多维度变化问题</p>
<h3 id="类图，以照片显示类为例"><a href="#类图，以照片显示类为例" class="headerlink" title="类图，以照片显示类为例"></a>类图，以照片显示类为例</h3><p><img src="/images/bridge.gif" alt=""></p>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Image interface &#123;</span><br><span class="line">	SetImageImpl(impl ImageImpl)</span><br><span class="line">	ParseFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GifImage struct &#123;</span><br><span class="line">	impl ImageImpl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *GifImage) SetImageImpl(i ImageImpl) &#123;</span><br><span class="line">	g.impl &#x3D; i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *GifImage) ParseFile() &#123;</span><br><span class="line">	fmt.Println(&quot;ParseFile of Gif&quot;)</span><br><span class="line">	m :&#x3D; Matrix&#123;&#125;</span><br><span class="line">	g.impl.DoPaint(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PNGImage struct &#123;</span><br><span class="line">	impl ImageImpl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *PNGImage) SetImageImpl(impl ImageImpl) &#123;</span><br><span class="line">	p.impl &#x3D; impl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *PNGImage) ParseFile() &#123;</span><br><span class="line">	fmt.Println(&quot;ParseFile of PNG&quot;)</span><br><span class="line">	m :&#x3D; Matrix&#123;&#125;</span><br><span class="line">	p.impl.DoPaint(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Matrix struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ImageImpl interface &#123;</span><br><span class="line">	DoPaint(Matrix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type WindowsImageImpl struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *WindowsImageImpl) DoPaint(matrix Matrix) &#123;</span><br><span class="line">	fmt.Print(&quot;在Windows上显示图像&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type LinuxImageImpl struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *LinuxImageImpl) DoPaint(m Matrix) &#123;</span><br><span class="line">	fmt.Print(&quot;在Linux上显示图像&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用测试"><a href="#客户端调用测试" class="headerlink" title="客户端调用测试"></a>客户端调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	win :&#x3D; new(WindowsImageImpl)</span><br><span class="line">	gif :&#x3D; new(GifImage)</span><br><span class="line">	gif.SetImageImpl(win)</span><br><span class="line">	gif.ParseFile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/bridge_client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-简单工厂模式</title>
    <url>/2020/04/12/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>简单工厂模式可以解决单体类过于庞大的问题</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/simple-factory.jpg" alt=""></p>
<a id="more"></a>

<h3 id="定义Chart和实现工厂方法"><a href="#定义Chart和实现工厂方法" class="headerlink" title="定义Chart和实现工厂方法"></a>定义Chart和实现工厂方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Chart interface &#123;</span><br><span class="line">	Display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ChartFactory(t string) Chart &#123;</span><br><span class="line">	switch t &#123;</span><br><span class="line">	case &quot;histogram&quot;:</span><br><span class="line">		return NewHistogramChart()</span><br><span class="line">	case &quot;line&quot;:</span><br><span class="line">		return NewLineChart()</span><br><span class="line">	case &quot;pie&quot;:</span><br><span class="line">		return NewPieChart()</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义HistogramChart"><a href="#定义HistogramChart" class="headerlink" title="定义HistogramChart"></a>定义HistogramChart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type HistogramChart struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewHistogramChart() *HistogramChart &#123;</span><br><span class="line">	fmt.Println(&quot;new NewHistogramChart&quot;)</span><br><span class="line">	return &amp;HistogramChart&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HistogramChart) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;display HistogramChart...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义LineChart"><a href="#定义LineChart" class="headerlink" title="定义LineChart"></a>定义LineChart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type LineChart struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewLineChart() *LineChart &#123;</span><br><span class="line">	fmt.Println(&quot;new NewLineChart&quot;)</span><br><span class="line">	return &amp;LineChart&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *LineChart) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;display LineChart...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义PieChart"><a href="#定义PieChart" class="headerlink" title="定义PieChart"></a>定义PieChart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type PieChart struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func NewPieChart() *PieChart &#123;</span><br><span class="line">	fmt.Println(&quot;new NewPieChart&quot;)</span><br><span class="line">	return &amp;PieChart&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *PieChart) Display() &#123;</span><br><span class="line">	fmt.Println(&quot;display PieChart...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c :&#x3D; ChartFactory(&quot;pie&quot;)</span><br><span class="line">	c.Display()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/simple-factory-client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>golang设计模式-适配器模式</title>
    <url>/2020/04/18/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>适配器模式解决接口不一致的问题</p>
<h3 id="类图，以分数操作为例"><a href="#类图，以分数操作为例" class="headerlink" title="类图，以分数操作为例"></a>类图，以分数操作为例</h3><p><img src="/images/adapter.jpg" alt=""></p>
<a id="more"></a>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type ScoreOperation interface &#123;</span><br><span class="line">	Sort([]int) []int</span><br><span class="line">	Search([]int, int) int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type OperationAdapter struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (o *OperationAdapter) Sort(a []int) []int &#123;</span><br><span class="line">	return quickSort(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (o *OperationAdapter) Search(a []int, k int) int &#123;</span><br><span class="line">	return binarySearch(a, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func quickSort(arr []int) []int &#123;</span><br><span class="line">	sort(arr, 0, len(arr)-1)</span><br><span class="line">	return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sort(arr []int, p, r int) &#123;</span><br><span class="line">	q :&#x3D; 0</span><br><span class="line">	if p &lt; r &#123;</span><br><span class="line">		q &#x3D; partition(arr, p, r)</span><br><span class="line">		sort(arr, p, q-1)</span><br><span class="line">		sort(arr, q+1, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func partition(arr []int, p, r int) int &#123;</span><br><span class="line">	x :&#x3D; arr[r]</span><br><span class="line">	j :&#x3D; p - 1</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; p; i &lt;&#x3D; r-1; i++ &#123;</span><br><span class="line">		if arr[i] &lt;&#x3D; x &#123;</span><br><span class="line">			j++</span><br><span class="line">			swap(arr, j, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr, j+1, r)</span><br><span class="line">	return j + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(arr []int, x, y int) &#123;</span><br><span class="line">	t :&#x3D; arr[x]</span><br><span class="line">	arr[x] &#x3D; arr[y]</span><br><span class="line">	arr[y] &#x3D; t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func binarySearch(arr []int, key int) int &#123;</span><br><span class="line">	low :&#x3D; 0</span><br><span class="line">	high :&#x3D; len(arr) - 1</span><br><span class="line">	for low &lt;&#x3D; high &#123;</span><br><span class="line">		mid :&#x3D; (low + high) &#x2F; 2</span><br><span class="line">		midVal :&#x3D; arr[mid]</span><br><span class="line">		if midVal &lt; key &#123;</span><br><span class="line">			low &#x3D; mid + 1</span><br><span class="line">		&#125; else if midVal &gt; key &#123;</span><br><span class="line">			high &#x3D; mid - 1</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return 1 &#x2F;&#x2F;找到元素返回1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1 &#x2F;&#x2F;未找到元素返回-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用测试"><a href="#调用测试" class="headerlink" title="调用测试"></a>调用测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var o ScoreOperation</span><br><span class="line">	o &#x3D; new(OperationAdapter)</span><br><span class="line">	a :&#x3D; []int&#123;1, 3, 2&#125;</span><br><span class="line">	fmt.Printf(&quot;before sort: %v\n&quot;, a)</span><br><span class="line">	o.Sort(a)</span><br><span class="line">	fmt.Printf(&quot;after sort: %v\n&quot;, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/adapter_client.PNG" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>小故事，值得一读</title>
    <url>/2019/04/02/%E5%B0%8F%E6%95%85%E4%BA%8B%EF%BC%8C%E5%80%BC%E5%BE%97%E4%B8%80%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>一个农民从洪水中救起了他的妻子，他的孩子却被淹死了。事后，人们议论纷纷。有的说他做得对，因为孩子可以再生一个，妻子却不能死而复活。有的说他做错了，因为妻子可以另娶一个，孩子却不能死而复活。<br>我听了人们的议论，也感到疑惑难决：如果只能救活一人，究竟应该救妻子呢，还是救孩子？ 于是我去拜访那个农民，问他当时是怎么想的。 他答道：“我什么也没想。洪水袭来，妻子在我身过，我抓住她就往附近的山坡游。 当我返回时，孩子已经被洪水冲走了。”<br>归途上，我琢磨着农民的话，对自己说：所谓人生的抉择不少便是如此。</p>
</blockquote>
<a id="more"></a>

<h3 id="一、用人之道"><a href="#一、用人之道" class="headerlink" title="一、用人之道"></a>一、用人之道</h3><p>去过庙的人都知道，一进庙门，首先是弥陀佛，笑脸迎客，而在他的北面，则是黑口黑脸的韦陀。但相传在很久以前，他们并不在同一个庙里，而是分别掌管不同的庙。弥乐佛热情快乐，所以来的人非常多，但他什么都不在乎，丢三拉四，没有好好的管理账务，所以依然入不敷出。而韦陀虽然管账是一把好手，但成天阴着个脸，太过严肃，搞得人越来越少，最后香火断绝。<br>佛祖在查香火的时候发现了这个问题，就将他们俩放在同一个庙里，由弥乐佛负责公关，笑迎八方客，于是香火大旺。而韦陀铁面无私，锱珠必较，则让他负责财务，严格把关。在两人的分工合作中，庙里一派欣欣向荣景象。其实在用人大师的眼里，没有废人，正如武功高手，不需名贵宝剑，摘花飞叶即可伤人，关键看如何运用。
　</p>
<h3 id="二、鹦-鹉"><a href="#二、鹦-鹉" class="headerlink" title="二、鹦 鹉"></a>二、鹦 鹉</h3><p>一个人去买鹦鹉，看到一只鹦鹉前标：此鹦鹉会两门语言，售价二百元。 另一只鹦鹉前则标道：此鹦鹉会四门语言，售价四百元。 该买哪只呢？两只都毛色光鲜，非常灵活可爱。这人转啊转，拿不定主意。 结果突然发现一只老掉了牙的鹦鹉，毛色暗淡散乱，标价八百元。<br>这人赶紧将老板叫来：这只鹦鹉是不是会说八门语言？ 店主说：不。 这人奇怪了：那为什么又老又丑，又没有能力，会值这个数呢？ 店主回答：因为另外两只鹦鹉叫这只鹦鹉老板。<br>这故事告诉我们，真正的领导人，不一定自己能力有多强，只要懂信任，懂放权，懂珍惜，就能团结比自己更强的力量，从而提升自己的身价。<br>相反许多能力非常强的人却因为过于完美主义，事必躬亲，什么人都不如自己，最后只能做最好的攻关人员，销售代表，成不了优秀的领导人。</p>
<h3 id="三、袋鼠与笼子"><a href="#三、袋鼠与笼子" class="headerlink" title="三、袋鼠与笼子"></a>三、袋鼠与笼子</h3><p>一天动物园管理员发现袋鼠从笼子里跑出来了，于是开会讨论，一致认为是笼子的高度过低。所以他们决定将笼子的高度由原来的10米加高到20米。结果第二天他们发现袋鼠还是跑到外面来，所以他们又决定再将高度加高到30米。<br>没想到隔天居然又看到袋鼠全跑到外面，于是管理员们大为紧张，决定一不做二不休，将笼子的高度加高到100米。一天长颈鹿和几只袋鼠们在闲聊，“你们看，这些人会不会再继续加高你们的笼子？<br>”长颈鹿问。“很难说。”袋鼠说∶“如果他们再继续忘记关门的话！”<br>管理心得：事有“本末”、“轻重”、“缓急”，关门是本，加高笼子是末，舍本而逐末，当然就不得要领了。管理是什么？管理就是先分析事情的主要矛盾和次要矛盾，认清事情的“本末”、“轻重”、“缓急”，然后从重要的方面下手。</p>
<h3 id="四、扁鹊的医术"><a href="#四、扁鹊的医术" class="headerlink" title="四、扁鹊的医术"></a>四、扁鹊的医术</h3><p>魏文王问名医扁鹊说：“你们家兄弟三人，都精于医术，到底哪一位最好呢？”<br>扁鹊答：“长兄最好，中兄次之，我最差。”<br>文王再问：“那么为什么你最出名呢？”<br>扁鹊答：“长兄治病，是治病于病情发作之前。由于一般人不知道他事先能铲除病因，所以他的名气无法传出去；中兄治病，是治病于病情初起时。一般人以为他只能治轻微的小病，所以他的名气只及本乡里。而我是治病于病情严重之时。一般人都看到我在经脉上穿针管放血、在皮肤上敷药等大手术，所以以为我的医术高明，名气因此响遍全国。”<br>管理心得：事后控制不如事中控制，事中控制不如事前控制，可惜大多数的事业经营者均未能体会到这一点，等到错误的决策造成了重大的损失才寻求弥补。而往往是即使请来了名气很大的“空降兵”，结果于事无补。</p>
<h3 id="五、曲突徒薪"><a href="#五、曲突徒薪" class="headerlink" title="五、曲突徒薪"></a>五、曲突徒薪</h3><p>有位客人到某人家里做客，看见主人家的灶上烟囱是直的，旁边又有很多木材。客人告诉主人说，烟囱要改曲，木材须移去，否则将来可能会有火灾，主人听了没有作任何表示。<br>不久主人家里果然失火，四周的邻居赶紧跑来救火，最后火被扑灭了，于是主人烹羊宰牛，宴请四邻，以酬谢他们救火的功劳，但并没有请当初建议他将木材移走，烟囱改曲的人。<br>有人对主人说：“如果当初听了那位先生的话，今天也不用准备筵席，而且没有火灾的损失，现在论功行赏，原先给你建议的人没有被感恩，而救火的人却是座上客，真是很奇怪的事呢！”主人顿时省悟，赶紧去邀请当初给予建议的那个客人来吃酒。管理心得：一般人认为，足以摆平或解决企业经营过程中的各种棘手问题的人，就是优秀的管理者，其实这是有待商榷的，俗话说：“预防重于治疗”，能防患于未然之前，更胜于治乱于已成之后，由此观之，企业问题的预防者，其实是优于企业问题的解决者。</p>
<h3 id="六、救-人"><a href="#六、救-人" class="headerlink" title="六、救 人"></a>六、救 人</h3><p>在一场激烈的战斗中，上尉忽然发现一架敌机向阵地俯冲下来。照常理，发现敌机俯冲时要毫不犹豫地卧倒。可上尉并没有立刻卧倒，他发现离他四五米远处有一个小战士还站在哪儿。他顾不上多想 ，一个鱼跃飞身将小战士紧紧地压在了身下。此时一声巨响，飞溅起来的泥土纷纷落在他们的身上。上尉拍拍身上的尘土，回头一看，顿时惊呆了：刚才自己所处的那个位置被炸成了一个大坑。</p>
<h3 id="七、出-门"><a href="#七、出-门" class="headerlink" title="七、出 门"></a>七、出 门</h3><p>古时候，有两个兄弟各自带着一只行李箱出远门。一路上，重重的行李箱将兄弟俩都压得 喘不过气来。他们只好左手累了换右手，右手累了又换左手。忽然，大哥停了下来，在路边买了一根扁担，将两个行李箱一左一右挂在扁担上。他挑起两个箱子上路，反倒觉得轻松了很多。<br>把这两个故事联系在一起也许有些牵强，但他们确实有着惊人的相似之处：故事中的小战士和弟弟是幸运的，但更加幸运的是故事中的上尉和大哥，因为他们在帮助别人的同时也帮助了自己！<br>管理心得：在我们人生的大道上，肯定会遇到许许多多的困难。但我们是不是都知道，在前进的道路上，搬开别人脚下的绊脚石，有时恰恰是为自己铺路？</p>
<h3 id="八、鱼王的儿子"><a href="#八、鱼王的儿子" class="headerlink" title="八、鱼王的儿子"></a>八、鱼王的儿子</h3><p>有个渔人有着一流的捕鱼技术，被人们尊称为‘渔王’。然而‘渔王’年老的时候非常苦恼，因为他的三个儿子的渔技都很平庸。<br>于是个经常向人诉说心中的苦恼：“我真不明白，我捕鱼的技术这么好，我的儿子们为什么这么差？我从他们懂事起就传授捕鱼技术给他们，从最基本的东西教起，告诉他们怎样织网最容易捕捉到鱼，怎样划船最不会惊动鱼，怎样下网最容易请鱼入瓮。他们长大了，我又教他们怎样识潮汐，辨鱼汛。。。凡是我长年辛辛苦苦总结出来的经验，我都毫无保留地传授给了他们，可他们的捕鱼技术竟然赶不上技术比我差的渔民的儿子！”<br>一位路人听了他的诉说后，问：“你一直手把手地教他们吗？”<br>“是的，为了让他们得到一流的捕鱼技术，我教得很仔细很耐心。”<br>“他们一直跟随着你吗？”<br>“是的，为了让他们少走弯路，我一直让他们跟着我学。”<br>路人说：“这样说来，你的错误就很明显了。你只传授给了他们技术，却没传授给他们教训，对于才能来说，没有教训与没有经验一样，都不能使人成大器！”</p>
]]></content>
  </entry>
</search>
